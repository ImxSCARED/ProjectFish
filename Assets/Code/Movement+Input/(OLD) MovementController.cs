using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class OldMovementController : MonoBehaviour
{
    // --EDITOR VARIABLES--

    // Private variables
    [SerializeField]
    Rigidbody m_rigidbody;
    [SerializeField]
    MeshCollider m_hullCollider;
    [SerializeField]
    float m_maxVelocity;
    [SerializeField]
    float m_speed;
    [SerializeField]
    float m_brakeSpeed;
    [SerializeField]
    float m_mass;                           // In kilograms
    [SerializeField]
    float m_maxPivotDisplacement;           // In metres
    [SerializeField]
    float m_turnResistance;
    [SerializeField]
    float m_rudderDragCoefficient;
    [SerializeField]
    float m_waterDensity = 997;             // In kg/m^3
    [SerializeField]
    float m_rudderTurnRate;
    [SerializeField]
    float m_rudderArea;                     // In metres^2
    [SerializeField]
    float m_maxRudderAngle = 35;            // In degrees

    // --CODE VARIABLES--

    // Static variables
    static Vector2 m_forward2D;

    static readonly float m_divisionFactor = 100;       // This is to counteract the fact that time.deltaTime makes numbers real small, so they're hard to manipulate in-editor

    // Private variables
    Vector2 m_velocity;
    float m_rotationalVelocity;

    float m_acceleration;
    float m_rotationalAcceleration;

    float m_pivotDisplacement;

    float m_centroidRotationalInertia;      // Required to calculate rotational inertia around some axis not in the centre
    float m_rotationalInertia;

    float m_rudderAngle;                    // In radians
    float m_heading;                        // In radians

    float m_realMaxVelocity;
    float m_realSpeed;
    float m_realBrakeSpeed;

    // --UNITY METHODS--
    void Awake()
    {
        m_forward2D = new(transform.forward.x, transform.forward.z);

        m_centroidRotationalInertia = (1/12) * m_mass * (m_hullCollider.bounds.size.x * m_hullCollider.bounds.size.x +          // Ic = (1/12)m(l^2 + w^2)
                                                         m_hullCollider.bounds.size.z * m_hullCollider.bounds.size.z);

    }

    void FixedUpdate()
    {
        // --SETUP--
        // Set "real" variables (so that the variables in the editor can be a nice number)
        m_realMaxVelocity = m_maxVelocity / m_divisionFactor;
        m_realSpeed = m_speed / m_divisionFactor;
        m_realBrakeSpeed = m_brakeSpeed / m_divisionFactor;

        // Set rotation axis
        m_pivotDisplacement = Mathf.Lerp(0, m_maxPivotDisplacement, m_velocity.magnitude / m_realMaxVelocity);

        m_rotationalInertia = m_centroidRotationalInertia + m_mass * (m_pivotDisplacement * m_pivotDisplacement); // I = Ic + md^2

        // --RUDDER--
        Mathf.Clamp(m_rudderAngle, -m_maxRudderAngle * Mathf.Deg2Rad, m_maxRudderAngle * Mathf.Deg2Rad);

        // --ACCELERATION--
        // Apply acceleration
        float lastForwardVelocity = (m_forward2D * Vector2.Dot(m_forward2D, m_velocity)).y;
        if (lastForwardVelocity + m_acceleration < 0)
        {
            m_acceleration = 0;

            Vector2 amountToZero = new(0, lastForwardVelocity);
            m_velocity -= amountToZero;
        }
        else
        {
            m_velocity += m_acceleration * m_forward2D;
        }

        // --VELOCITY--
        // Cap movement velocity
        // Accounts for diagonal movement
        if (m_velocity.magnitude > m_realMaxVelocity)
        {
            m_velocity.x = m_velocity.normalized.x * m_realMaxVelocity;
            m_velocity.y = m_velocity.normalized.y * m_realMaxVelocity;
        }

        // Apply velocity
        Vector3 velocity3 = new(m_velocity.x, 0, m_velocity.y);
        m_rigidbody.MovePosition(transform.position + velocity3);

        // --ROTATION--
        // Find torque generated by our rudder
        float forwardVelocity = (m_forward2D * Vector2.Dot(m_forward2D, m_velocity)).y;
        float torque = Mathf.Sin(m_rudderAngle) * m_rudderArea * forwardVelocity * m_waterDensity * m_pivotDisplacement;

        m_rotationalVelocity += torque;

        m_rigidbody.MoveRotation(Quaternion.Euler(0, m_rotationalVelocity, 0));
    }

    // --PUBLIC METHODS--
    /// <summary>
    /// Increases the boat's acceleration.
    /// </summary>
    /// <param name="magnitude">The magnitude by which speed is applied to the player's acceleration.</param>
    public void Accelerate(float magnitude = 1)
    {
        float acceleration = magnitude * (magnitude > 0 ? m_realSpeed : m_realBrakeSpeed);
        acceleration *= Time.deltaTime;

        m_acceleration = acceleration;
    }

    /// <summary>
    /// Adds some velocity, controlled by the player's speed, to the object's current turning velocity.
    /// </summary>
    /// <param name="magnitude">How sharply the boat should turn (-1 to 1).</param>
    public void Turn(float magnitude)
    {
        float eulerTurn = magnitude * m_rudderTurnRate * Time.deltaTime;

        m_rudderAngle += eulerTurn;
    }

    /*/// <summary>
    /// Brings a value closer to 0 by some amount determined by friction
    /// </summary>
    /// <param name="initialSpeed">The speed before friction is applied</param>
    /// <param name="friction">The amount to apply to initialSpeed</param>
    /// <returns>The speed after friction is applied</returns>
    private float ApplyFriction(float initialSpeed, float friction)
    {
        // Sign agnostic - if positive, this will subtract toward 0, if negative, it will add toward 0
        if (Mathf.Abs(initialSpeed) - (friction * Time.deltaTime) <= 0)
        {
            return 0;
        }
        else
        {
            return initialSpeed - Mathf.Sign(initialSpeed) * friction * Time.deltaTime;
        }
    }*/
}
